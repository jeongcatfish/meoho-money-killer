import dokang/POA/9 as POA

//@version=5
strategy("Bollinger Bands - Breakout Strategy",overlay=true, 
         initial_capital=10000, 
         default_qty_type=strategy.percent_of_equity, default_qty_value=10,
         slippage=1, backtest_fill_limits_assumption=1, use_bar_magnifier=true,
         commission_type=strategy.commission.percent, commission_value=0.025
         )

// Calc Date 
start_time = input.time(defval = timestamp("31 Dec 2000 15:00 +0000"), title = "Start   ", inline="timestart", group='TRADE SETTING')
end_time = input.time(defval = timestamp("31 Dec 2099 00:00 +0000"), title = "End  ", inline="timeend", group='TRADE SETTING')
timeCond = (time > start_time) and (time < end_time)

active_long = input.bool(true, "Activate Long", inline="activate")
active_short = input.bool(true, "Activate Short", inline="activate")

select_bot = input.string('PoA Bot', 'Select Your Bot ', options=['PoA Bot', 'TVExtBot'], inline="bot")

//POA BOT
password = input.string(defval='password', title='Password ', inline="pw", group='POA Bot')
in_trade = POA.in_trade(start_time, end_time)

//TVEXTBOT
tvextbot_long_entry  = input.string("Long Entry Message", "Entry   ", inline='entry', group='TVExtBot')
tvextbot_long_exit   = input.string("Long TP Message", "TP     ", inline='tp', group='TVExtBot')
tvextbot_long_close  = input.string("Long Close Message", "Close   ", inline='close', group='TVExtBot')

tvextbot_short_entry = input.string("Short Entry Message", "", inline='entry', group='TVExtBot')
tvextbot_short_eixt  = input.string("Short TP Message", "", inline='tp', group='TVExtBot')
tvextbot_short_close = input.string("Short Close Message", "", inline='close', group='TVExtBot')

//Alert Message 
long_entry_message(user_input_style) =>
    user_input_style == 'PoA Bot' ? POA.entry_message(password) : user_input_style == 'TVExtBot' ? tvextbot_long_entry : na
long_exit_message(user_input_style) =>
    user_input_style == 'PoA Bot' ? POA.exit_message(password) : user_input_style == 'TVExtBot' ? tvextbot_long_exit : na
long_close_message(user_input_style) =>
    user_input_style == 'PoA Bot' ? POA.close_message(password) : user_input_style == 'TVExtBot' ? tvextbot_long_close : na

short_entry_message(user_input_style) =>
    user_input_style == 'PoA Bot' ? POA.entry_message(password) : user_input_style == 'TVExtBot' ? tvextbot_short_entry : na
short_exit_message(user_input_style) =>
    user_input_style == 'PoA Bot' ? POA.exit_message(password) : user_input_style == 'TVExtBot' ? tvextbot_short_eixt : na
short_close_message(user_input_style) =>
    user_input_style == 'PoA Bot' ? POA.close_message(password) : user_input_style == 'TVExtBot' ? tvextbot_short_close : na

// Define the length of the Bollinger Bands
bbLengthInput = input.int (15,title="Length", group="Bollinger Bands", inline="BB")
bbDevInput = input.float (2.0,title="StdDev", group="Bollinger Bands", inline="BB")

// Define the settings for the Trend Filter
trendFilterInput = input.bool(false, title="Above/Below", group = "Trend Filter", inline="Trend")
trendFilterPeriodInput = input(223,title="", group = "Trend Filter", inline="Trend")
trendFilterType = input.string (title="", defval="EMA",options=["EMA","SMA","RMA", "WMA"], group = "Trend Filter", inline="Trend")

volatilityFilterInput = input.bool(true,title="StdDev", group = "Volatility Filter", inline="Vol")
volatilityFilterStDevLength = input(15,title="",group = "Volatility Filter", inline="Vol")
volatilityStDevMaLength = input(15,title=">MA",group = "Volatility Filter", inline="Vol")

// ROC Filter

// f_security function by LucF for PineCoders available here: https://www.tradingview.com/script/cyPWY96u-How-to-avoid-repainting-when-using-security-PineCoders-FAQ/
f_security(_sym, _res, _src, _rep) => request.security(_sym, _res, _src[not _rep and barstate.isrealtime ? 1 : 0])[_rep or barstate.isrealtime ? 0 : 1]
high_daily = f_security(syminfo.tickerid, "D", high, false)

roc_enable = input.bool(false, "", group="ROC Filter from CloseD", inline="roc")
roc_threshold = input.float(1, "Treshold", step=0.5, group="ROC Filter from CloseD", inline="roc")

closed = f_security(syminfo.tickerid,"1D",close, false)
roc_filter= roc_enable ? (close-closed)/closed*100  > roc_threshold : true

// Trade Direction Filter

tradeDirectionInput = input.string("Auto",options=["Auto", "Long&Short","Long Only", "Short Only"], title="Trade ", inline="trade", group="Direction Filter", tooltip="Auto: if a PERP is detected (in the symbol description), trade long and short\n Otherwise as per user-input")

tradeDirection = switch tradeDirectionInput
	"Auto" => str.contains(str.lower(syminfo.description), "perp") or str.contains(str.lower(syminfo.description), ".p") ? strategy.direction.all : strategy.direction.long
	"Long&Short" => strategy.direction.all
	"Long Only" => strategy.direction.long
    "Short Only" => strategy.direction.short
	=> strategy.direction.all

strategy.risk.allow_entry_in(tradeDirection)


// Calculate and plot the Bollinger Bands
[bbMiddle, bbUpper, bbLower] = ta.bb (close, bbLengthInput, bbDevInput)

plot(bbMiddle, "Basis", color=color.orange)
bbUpperPlot = plot(bbUpper, "Upper", color=color.blue)
bbLowerrPlot = plot(bbLower, "Lower", color=color.blue)
fill(bbUpperPlot, bbLowerrPlot, title = "Background", color=color.new(color.blue, 95))


// Calculate and view Trend Filter

float tradeConditionMa = switch trendFilterType
	"EMA" => ta.ema(close, trendFilterPeriodInput)
	"SMA" => ta.sma(close, trendFilterPeriodInput)
	"RMA" => ta.rma(close, trendFilterPeriodInput)
    "WMA" => ta.wma(close, trendFilterPeriodInput)
	// Default used when the three first cases do not match.
	=> ta.wma(close, trendFilterPeriodInput)


trendConditionLong  = trendFilterInput ? close > tradeConditionMa : true
trendConditionShort = trendFilterInput ? close < tradeConditionMa : true
plot(trendFilterInput ? tradeConditionMa : na, color=color.yellow)

// Calculate and view Volatility Filter

stdDevClose = ta.stdev(close,volatilityFilterStDevLength)
volatilityCondition = volatilityFilterInput ? stdDevClose > ta.sma(stdDevClose,volatilityStDevMaLength) : true

bbLowerCrossUnder =  ta.crossunder(close, bbLower)
bbUpperCrossOver =  ta.crossover(close, bbUpper)

bgcolor(volatilityCondition ? na : color.new(color.red, 95))

// Entry and Exit Conditions

entryLongCondition = bbUpperCrossOver and trendConditionLong and volatilityCondition and in_trade and roc_filter
entryShortCondition = bbLowerCrossUnder and trendConditionShort and volatilityCondition and in_trade and roc_filter

exitLongCondition = bbLowerCrossUnder
exitShortCondition = bbUpperCrossOver

// Orders

if active_long and entryLongCondition
    strategy.entry("EL", strategy.long, alert_message=long_entry_message(select_bot))

if active_short and entryShortCondition
    strategy.entry("ES", strategy.short, alert_message=short_entry_message(select_bot))

if exitLongCondition
    strategy.close("EL", alert_message=long_close_message(select_bot))

if exitShortCondition
    strategy.close("ES", alert_message=short_close_message(select_bot))



// Long SL/TP/TS

xl_ts_percent      = input.float(2,step=0.5, title= "TS", group="Exit Long", inline="LTS", tooltip="Trailing Treshold %")
xl_to_percent      = input.float(0.5, step=0.5, title= "TO", group="Exit Long", inline="LTS", tooltip="Trailing Offset %")

xl_ts_tick = xl_ts_percent * close/syminfo.mintick/100
xl_to_tick = xl_to_percent * close/syminfo.mintick/100

xl_sl_percent      = input.float (2, step=0.5, title="SL",group="Exit Long", inline="LSLTP") 
xl_tp_percent      = input.float(9, step=0.5, title="TP",group="Exit Long", inline="LSLTP")

xl_sl_price = strategy.position_avg_price * (1-xl_sl_percent/100)
xl_tp_price = strategy.position_avg_price * (1+xl_tp_percent/100)

strategy.exit("XL+SL/TP", "EL", stop=xl_sl_price, limit=xl_tp_price, trail_points=xl_ts_tick, trail_offset=xl_to_tick,comment_loss= "XL-SL", comment_profit = "XL-TP",comment_trailing = "XL-TS", alert_message=long_exit_message(select_bot))

// Short SL/TP/TS
xs_ts_percent      = input.float(2,step=0.5, title= "TS",group="Exit Short", inline ="STS", tooltip="Trailing Treshold %")
xs_to_percent      = input.float(0.5, step=0.5, title= "TO",group="Exit Short", inline ="STS", tooltip="Trailing Offset %")

xs_ts_tick = xs_ts_percent * close/syminfo.mintick/100
xs_to_tick = xs_to_percent * close/syminfo.mintick/100

xs_sl_percent      = input.float (2, step=0.5, title="SL",group="Exit Short", inline="ESSLTP", tooltip="Stop Loss %") 
xs_tp_percent      = input.float(9, step=0.5, title="TP",group="Exit Short",  inline="ESSLTP", tooltip="Take Profit %")

xs_sl_price = strategy.position_avg_price * (1+xs_sl_percent/100)
xs_tp_price = strategy.position_avg_price * (1-xs_tp_percent/100)

strategy.exit("XS+SL/TP", "ES", stop=xs_sl_price, limit=xs_tp_price, trail_points=xs_ts_tick, trail_offset=xs_to_tick,comment_loss= "XS-SL", comment_profit = "XS-TP",comment_trailing = "XS-TS", alert_message=short_exit_message(select_bot))


max_intraday_loss = input.int(10, title="Max Intraday Loss (Percent)", group="Risk Management")

strategy.risk.max_intraday_loss(max_intraday_loss, strategy.percent_of_equity)

//Table

PnL = strategy.grossprofit - strategy.grossloss
ex_PnL = math.round(strategy.openprofit, 1)

totalbalance = strategy.initial_capital + strategy.netprofit

used_equity = math.round(strategy.position_avg_price * strategy.position_size)
ratio_equity = strategy.position_size > 0 ? math.round(used_equity / totalbalance * 100, 1) : 0

mdd = strategy.opentrades.max_drawdown(strategy.opentrades - 1)

totalTrades = strategy.closedtrades
winningTrades = na(totalTrades) ? na : totalTrades - strategy.losstrades

winRate = totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0

profitFactor = math.abs(strategy.grossprofit) > 0 ? strategy.grossprofit / math.abs(strategy.grossloss) : na

avgBarsPerTrade() =>
    sumBarsPerTrade = 0
    for tradeNo = 0 to strategy.closedtrades - 1
        // Loop through all closed trades, starting with the oldest.
        sumBarsPerTrade += strategy.closedtrades.exit_bar_index(tradeNo) - strategy.closedtrades.entry_bar_index(tradeNo) + 1
    result = nz(sumBarsPerTrade / strategy.closedtrades)

show_status           = input.bool(true,'', group='Status Table', inline='t1')
status_text_size      = input.string(size.tiny, 'Size ', options=[size.tiny, size.small, size.normal], group='Status Table', inline='t1')
status_table_position = input.string(position.bottom_left, 'Position ', options=[position.bottom_left, position.bottom_right, position.bottom_center, position.top_left, position.top_right, position.top_center], group='Status Table', inline='t1')

show_performance           = input.bool(true, '', group='Profit Table', inline='t2')
performance_text_size      = input.string(size.small, 'Size ', options=[size.tiny, size.small, size.normal], group='Profit Table', inline='t2')
performance_table_position = input.string(position.bottom_right, 'Position ', options=[position.bottom_left, position.bottom_right, position.bottom_center, position.top_left, position.top_right, position.top_center], group='Profit Table', inline='t2')

// ------------------------------------------------------------------------------------------------------------------ //

profit_color1 = PnL > 0 ? color.lime : color.red
profit_color2 = strategy.openprofit < 0 ? color.red : color.lime

var Table = table.new(status_table_position, columns=10, rows=20, border_width=1, bgcolor=color.black, border_color=color.gray)

if show_status
    table.cell(table_id=Table, column=0, row=0, text='Position Size', text_size=status_text_size, text_color=color.gray)
    table.cell(table_id=Table, column=0, row=1, text=str.tostring(strategy.position_size), text_size=status_text_size, text_color=color.green)
    table.cell(table_id=Table, column=0, row=2, text='Avg Price', text_size=status_text_size, text_color=color.gray)
    table.cell(table_id=Table, column=0, row=3, text=str.tostring(math.round_to_mintick(strategy.position_avg_price)), text_size=status_text_size, text_color=color.green)

    table.cell(table_id=Table, column=1, row=0, text='Unrealized PnL', text_size=status_text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=1, text=str.tostring(math.round(strategy.openprofit, 1)) + ' ' + syminfo.currency, text_size=status_text_size, text_color=profit_color2)
    table.cell(table_id=Table, column=1, row=2, text_color=color.gray, text_size=status_text_size, text='Net profit')
    table.cell(table_id=Table, column=1, row=3, text=str.tostring(math.round(PnL, 1)) + ' ' + syminfo.currency, text_size=status_text_size, text_color=profit_color1)

    table.cell(table_id=Table, column=2, row=0, text='Win Rate', text_size=status_text_size, text_color=color.gray)
    table.cell(table_id=Table, column=2, row=1, text=str.tostring(math.round(winRate, 1)), text_size=status_text_size, text_color=color.green)
    table.cell(table_id=Table, column=2, row=2, text='Profit Factor', text_size=status_text_size, text_color=color.gray)
    table.cell(table_id=Table, column=2, row=3, text=str.tostring(math.round(profitFactor, 2)), text_size=status_text_size, text_color=color.olive)

    table.cell(table_id=Table, column=4, row=0, text='Max Drawdown', text_size=status_text_size, text_color=color.gray)
    table.cell(table_id=Table, column=4, row=1, text=str.tostring(math.round(mdd, 1)), text_size=status_text_size, text_color=color.green)
    table.cell(table_id=Table, column=4, row=2, text='Bars Per Trade', text_size=status_text_size, text_color=color.gray)
    table.cell(table_id=Table, column=4, row=3, text=str.tostring(int(avgBarsPerTrade())), text_size=status_text_size, text_color=color.olive)

if show_performance
    new_month = month(time) != month(time[1])
    new_year  = year(time)  != year(time[1])
    
    eq = strategy.initial_capital + strategy.netprofit
    
    bar_pnl = eq / eq[1] - 1
    
    cur_month_pnl = 0.0
    cur_year_pnl  = 0.0
    
    // Current Monthly P&L
    cur_month_pnl := new_month ? 0.0 : 
                     (1 + cur_month_pnl[1]) * (1 + bar_pnl) - 1 
    
    // Current Yearly P&L
    cur_year_pnl := new_year ? 0.0 : 
                     (1 + cur_year_pnl[1]) * (1 + bar_pnl) - 1  
    
    // Arrays to store Yearly and Monthly P&Ls
    var month_pnl  = array.new_float(0)
    var month_time = array.new_int(0)
    
    var year_pnl  = array.new_float(0)
    var year_time = array.new_int(0)
    
    last_computed = false
    
    if (not na(cur_month_pnl[1]) and (new_month or barstate.islastconfirmedhistory))
        if (last_computed[1])
            array.pop(month_pnl)
            array.pop(month_time)
            
        array.push(month_pnl , cur_month_pnl[1])
        array.push(month_time, time[1])
    
    if (not na(cur_year_pnl[1]) and (new_year or barstate.islastconfirmedhistory))
        if (last_computed[1])
            array.pop(year_pnl)
            array.pop(year_time)
            
        array.push(year_pnl , cur_year_pnl[1])
        array.push(year_time, time[1])
    
    last_computed := barstate.islastconfirmedhistory ? true : nz(last_computed[1])
    
    // Monthly P&L Table    
    var monthly_table = table(na)
    
    if (barstate.islastconfirmedhistory)
        monthly_table := table.new(performance_table_position, columns = 14, rows = array.size(year_pnl) + 1, border_width = 1)
    
        table.cell(monthly_table, 0,  0, "", text_size=performance_text_size,     bgcolor = color.gray)
        table.cell(monthly_table, 1,  0, "Jan", text_size=performance_text_size,  bgcolor = color.gray)
        table.cell(monthly_table, 2,  0, "Feb", text_size=performance_text_size,  bgcolor = color.gray)
        table.cell(monthly_table, 3,  0, "Mar", text_size=performance_text_size,  bgcolor = color.gray)
        table.cell(monthly_table, 4,  0, "Apr", text_size=performance_text_size,  bgcolor = color.gray)
        table.cell(monthly_table, 5,  0, "May", text_size=performance_text_size,  bgcolor = color.gray)
        table.cell(monthly_table, 6,  0, "Jun", text_size=performance_text_size,  bgcolor = color.gray)
        table.cell(monthly_table, 7,  0, "Jul", text_size=performance_text_size,  bgcolor = color.gray)
        table.cell(monthly_table, 8,  0, "Aug", text_size=performance_text_size,  bgcolor = color.gray)
        table.cell(monthly_table, 9,  0, "Sep", text_size=performance_text_size,  bgcolor = color.gray)
        table.cell(monthly_table, 10, 0, "Oct", text_size=performance_text_size,  bgcolor = color.gray)
        table.cell(monthly_table, 11, 0, "Nov", text_size=performance_text_size,  bgcolor = color.gray)
        table.cell(monthly_table, 12, 0, "Dec", text_size=performance_text_size,  bgcolor = color.gray)
        table.cell(monthly_table, 13, 0, "Year", text_size=performance_text_size, bgcolor = color.gray)
    
    
        for yi = 0 to array.size(year_pnl) - 1
            table.cell(monthly_table, 0,  yi + 1, str.tostring(year(array.get(year_time, yi))), text_size=performance_text_size, bgcolor = color.gray)
            
            y_color = array.get(year_pnl, yi) > 0 ? color.new(color.teal, transp = 40) : color.new(color.gray, transp = 40)
            table.cell(monthly_table, 13, yi + 1, str.tostring(math.round(array.get(year_pnl, yi) * 100, 1)), bgcolor = y_color, text_size=performance_text_size, text_color=color.new(color.white, 0))
            
        for mi = 0 to array.size(month_time) - 1
            m_row   = year(array.get(month_time, mi))  - year(array.get(year_time, 0)) + 1
            m_col   = month(array.get(month_time, mi)) 
            m_color = array.get(month_pnl, mi) > 0 ? color.new(color.teal, transp = 40) : color.new(color.gray, transp = 40)
            
            table.cell(monthly_table, m_col, m_row, str.tostring(math.round(array.get(month_pnl, mi) * 100, 1)), bgcolor = m_color, text_size=performance_text_size, text_color=color.new(color.white, 0))
